Protocol by derfarctor

ECIES Over Ed25519 to send messages on the nano/banano blockchain
with thanks to https://github.com/phayes/ecies-ed25519

Alice wishes to send a message to Bob.
1. Alice makes note of Bob's account address and derives his public key.
2A. Alice generates an ephemeral keypair, and uses the ephemeral private key along with Bob's public key to generate a secret key. (For 
a more in depth explanation of how the secret is derived, see https://www.nominet.uk/how-elliptic-curve-cryptography-encryption-works)
2B. Mindful of the 60 byte overhead of AES-GCM (32 byte public key + 12 byte nonce + 16 byte MAC), Alice pads her plaintext message 
with whitespace such that the ciphertext will be a multiple of 32 bytes and can easily be converted into regular account addresses.
3. Alice then encrypts her message with this secret key, and precedes it with the ephemeral public key to form the completed ciphertext.
4. The complete ciphertext is then split into 32 byte blocks and encoded into account addresses.
5. Starting at the first block's account address, Alice publishes a state block changing representative to the account address
until the message is sequenced in order in her chain.
6. Alice notes the block hash of the first block she sent, and converts this into bytes and then into an account address.
7. She sends Bob 1 raw and in the same transaction sets the representative to this account address.
8. The message has been sent and is ready for Bob to read.

Bob notices and wishes to read a message from Alice.
1. Bob notices a 1 raw transaction and notes the representative field of the block, and the height in Alice's chain.
2. He converts the representative account address to a public key and then into hexadecimal form.
3. Bob queries a network node with the hexadecimal as a block hash, and again notes the representative field and the height in Alice's chain.
4. After subtracting the height in step 3. from that of step 1. Bob knows the number of blocks he will need to query to begin decrypting 
the message and can decide if he wishes to continue.
5. Assuming Bob continues, he will start at the 1 raw transaction in Alice's chain and note the 'previous' block data field which shows the block hash of 
the previous block in her chain.
6. Bob adds the representative account address of this block to a list and then moves again onto the preceding block via the hash contained in the 'previous' field.
This continues until the previous block is the hash from step 2. at which point Bob knows he is at the beginning of the message.
7. After adding the final account address to the list, Bob works starting at the end of the list and pops each account address in turn, 
converting it into public key bytes and concatenating them as he goes.
8. Bob takes the byte concatenation and extracts the first 32, noting them as the ephemeral public key generated by Alice.
9. Using Alice's ephemeral public key and Bob's own private key, he regenerates the secret key which he then uses to decrypt the remaining ciphertext.
10. Bob trims trailing whitespace potentially created by Alice when padding the plaintext. The message is received.