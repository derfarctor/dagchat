Protocol by derfarctor

ECIES Over Ed25519 to send messages on the nano/banano blockchain
with thanks to https://github.com/phayes/ecies-ed25519

Alice wishes to send a message to Bob.
1. Alice makes note of Bob's account address and derives his public key.
2A. Alice generates an ephemeral keypair, and uses the ephemeral private key along with Bob's public key to generate a secret key. (For a more in depth explanation of how the secret is derived, see https://www.nominet.uk/how-elliptic-curve-cryptography-encryption-works)
2B. Mindful of the 60 byte overhead of AES-GCM (32 byte public key + 12 byte nonce + 16 byte MAC), Alice pads her plaintext message with whitespace such that the ciphertext will be a multiple of 32 bytes and can easily be converted into regular account addresses.
3. Alice then encrypts her message with this secret key, and precedes it with the ephemeral public key to form the completed ciphertext.
4. The complete ciphertext is then split into 32 byte blocks and encoded into account addresses.
5. Starting at the first block's account address, Alice publishes a state block changing representative to the account address and repeats until the message is sequenced in order in her chain.
6. Alice notes the block hash of the first representative change block she published, and converts this into bytes and then into an account address.
7. She sends Bob 1 raw and in the same transaction sets the representative to this account address.
8. The message has been sent and is ready for Bob to read.

Bob notices and wishes to read a message from Alice.
1. Bob notices a 1 raw receivable transaction and notes the representative field of the block, and the height in Alice's chain.
2. He converts the representative account address to a public key and then into hexadecimal form.
3. Bob queries a network node with the hexadecimal string as a block hash, and again notes the representative field and the height in Alice's chain of the block.
4. After subtracting the height in step 3. from that of step 1. Bob knows the number of blocks he will need to query to begin decrypting the message and can decide if he wishes to continue.
5. Assuming Bob continues, he requests and notes the blocks between these two heights (including the block from step 3. but not that of 1.) and orders them in a list starting from the lowest height.
6. Starting at the first block (which will be the first of the message), Bob works out the byte equivalence of the representative field and adds these bytes to a list, repeating this process for each block until the list contains all of the encrypted bytes of the ciphertext.
7. Bob takes the byte concatenation and extracts the first 32, noting them as the ephemeral public key generated by Alice.
8. Using Alice's ephemeral public key and Bob's own private key, he regenerates the secret key which he then uses to decrypt the remaining ciphertext.
9. Bob trims trailing whitespace potentially created by Alice when padding the plaintext. The message is received.